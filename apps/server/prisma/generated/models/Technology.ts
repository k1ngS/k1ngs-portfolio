/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/**
 * This file exports the `Technology` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model Technology
 *
 */
export type TechnologyModel =
	runtime.Types.Result.DefaultSelection<Prisma.$TechnologyPayload>;

export type AggregateTechnology = {
	_count: TechnologyCountAggregateOutputType | null;
	_avg: TechnologyAvgAggregateOutputType | null;
	_sum: TechnologySumAggregateOutputType | null;
	_min: TechnologyMinAggregateOutputType | null;
	_max: TechnologyMaxAggregateOutputType | null;
};

export type TechnologyAvgAggregateOutputType = {
	order: number | null;
};

export type TechnologySumAggregateOutputType = {
	order: number | null;
};

export type TechnologyMinAggregateOutputType = {
	id: string | null;
	name: string | null;
	icon: string | null;
	color: string | null;
	category: $Enums.TechnologyCategory | null;
	order: number | null;
};

export type TechnologyMaxAggregateOutputType = {
	id: string | null;
	name: string | null;
	icon: string | null;
	color: string | null;
	category: $Enums.TechnologyCategory | null;
	order: number | null;
};

export type TechnologyCountAggregateOutputType = {
	id: number;
	name: number;
	icon: number;
	color: number;
	category: number;
	order: number;
	_all: number;
};

export type TechnologyAvgAggregateInputType = {
	order?: true;
};

export type TechnologySumAggregateInputType = {
	order?: true;
};

export type TechnologyMinAggregateInputType = {
	id?: true;
	name?: true;
	icon?: true;
	color?: true;
	category?: true;
	order?: true;
};

export type TechnologyMaxAggregateInputType = {
	id?: true;
	name?: true;
	icon?: true;
	color?: true;
	category?: true;
	order?: true;
};

export type TechnologyCountAggregateInputType = {
	id?: true;
	name?: true;
	icon?: true;
	color?: true;
	category?: true;
	order?: true;
	_all?: true;
};

export type TechnologyAggregateArgs<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Technology to aggregate.
	 */
	where?: Prisma.TechnologyWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Technologies to fetch.
	 */
	orderBy?:
		| Prisma.TechnologyOrderByWithRelationInput
		| Prisma.TechnologyOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.TechnologyWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Technologies from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Technologies.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Technologies
	 **/
	_count?: true | TechnologyCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: TechnologyAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: TechnologySumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: TechnologyMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: TechnologyMaxAggregateInputType;
};

export type GetTechnologyAggregateType<T extends TechnologyAggregateArgs> = {
	[P in keyof T & keyof AggregateTechnology]: P extends "_count" | "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateTechnology[P]>
		: Prisma.GetScalarType<T[P], AggregateTechnology[P]>;
};

export type TechnologyGroupByArgs<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.TechnologyWhereInput;
	orderBy?:
		| Prisma.TechnologyOrderByWithAggregationInput
		| Prisma.TechnologyOrderByWithAggregationInput[];
	by: Prisma.TechnologyScalarFieldEnum[] | Prisma.TechnologyScalarFieldEnum;
	having?: Prisma.TechnologyScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: TechnologyCountAggregateInputType | true;
	_avg?: TechnologyAvgAggregateInputType;
	_sum?: TechnologySumAggregateInputType;
	_min?: TechnologyMinAggregateInputType;
	_max?: TechnologyMaxAggregateInputType;
};

export type TechnologyGroupByOutputType = {
	id: string;
	name: string;
	icon: string | null;
	color: string | null;
	category: $Enums.TechnologyCategory | null;
	order: number;
	_count: TechnologyCountAggregateOutputType | null;
	_avg: TechnologyAvgAggregateOutputType | null;
	_sum: TechnologySumAggregateOutputType | null;
	_min: TechnologyMinAggregateOutputType | null;
	_max: TechnologyMaxAggregateOutputType | null;
};

type GetTechnologyGroupByPayload<T extends TechnologyGroupByArgs> =
	Prisma.PrismaPromise<
		Array<
			Prisma.PickEnumerable<TechnologyGroupByOutputType, T["by"]> & {
				[P in keyof T & keyof TechnologyGroupByOutputType]: P extends "_count"
					? T[P] extends boolean
						? number
						: Prisma.GetScalarType<T[P], TechnologyGroupByOutputType[P]>
					: Prisma.GetScalarType<T[P], TechnologyGroupByOutputType[P]>;
			}
		>
	>;

export type TechnologyWhereInput = {
	AND?: Prisma.TechnologyWhereInput | Prisma.TechnologyWhereInput[];
	OR?: Prisma.TechnologyWhereInput[];
	NOT?: Prisma.TechnologyWhereInput | Prisma.TechnologyWhereInput[];
	id?: Prisma.StringFilter<"Technology"> | string;
	name?: Prisma.StringFilter<"Technology"> | string;
	icon?: Prisma.StringNullableFilter<"Technology"> | string | null;
	color?: Prisma.StringNullableFilter<"Technology"> | string | null;
	category?:
		| Prisma.EnumTechnologyCategoryNullableFilter<"Technology">
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntFilter<"Technology"> | number;
	projects?: Prisma.ProjectTechnologyListRelationFilter;
	skills?: Prisma.SkillListRelationFilter;
};

export type TechnologyOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	icon?: Prisma.SortOrderInput | Prisma.SortOrder;
	color?: Prisma.SortOrderInput | Prisma.SortOrder;
	category?: Prisma.SortOrderInput | Prisma.SortOrder;
	order?: Prisma.SortOrder;
	projects?: Prisma.ProjectTechnologyOrderByRelationAggregateInput;
	skills?: Prisma.SkillOrderByRelationAggregateInput;
};

export type TechnologyWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		name?: string;
		AND?: Prisma.TechnologyWhereInput | Prisma.TechnologyWhereInput[];
		OR?: Prisma.TechnologyWhereInput[];
		NOT?: Prisma.TechnologyWhereInput | Prisma.TechnologyWhereInput[];
		icon?: Prisma.StringNullableFilter<"Technology"> | string | null;
		color?: Prisma.StringNullableFilter<"Technology"> | string | null;
		category?:
			| Prisma.EnumTechnologyCategoryNullableFilter<"Technology">
			| $Enums.TechnologyCategory
			| null;
		order?: Prisma.IntFilter<"Technology"> | number;
		projects?: Prisma.ProjectTechnologyListRelationFilter;
		skills?: Prisma.SkillListRelationFilter;
	},
	"id" | "name"
>;

export type TechnologyOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	icon?: Prisma.SortOrderInput | Prisma.SortOrder;
	color?: Prisma.SortOrderInput | Prisma.SortOrder;
	category?: Prisma.SortOrderInput | Prisma.SortOrder;
	order?: Prisma.SortOrder;
	_count?: Prisma.TechnologyCountOrderByAggregateInput;
	_avg?: Prisma.TechnologyAvgOrderByAggregateInput;
	_max?: Prisma.TechnologyMaxOrderByAggregateInput;
	_min?: Prisma.TechnologyMinOrderByAggregateInput;
	_sum?: Prisma.TechnologySumOrderByAggregateInput;
};

export type TechnologyScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.TechnologyScalarWhereWithAggregatesInput
		| Prisma.TechnologyScalarWhereWithAggregatesInput[];
	OR?: Prisma.TechnologyScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.TechnologyScalarWhereWithAggregatesInput
		| Prisma.TechnologyScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"Technology"> | string;
	name?: Prisma.StringWithAggregatesFilter<"Technology"> | string;
	icon?:
		| Prisma.StringNullableWithAggregatesFilter<"Technology">
		| string
		| null;
	color?:
		| Prisma.StringNullableWithAggregatesFilter<"Technology">
		| string
		| null;
	category?:
		| Prisma.EnumTechnologyCategoryNullableWithAggregatesFilter<"Technology">
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntWithAggregatesFilter<"Technology"> | number;
};

export type TechnologyCreateInput = {
	id?: string;
	name: string;
	icon?: string | null;
	color?: string | null;
	category?: $Enums.TechnologyCategory | null;
	order?: number;
	projects?: Prisma.ProjectTechnologyCreateNestedManyWithoutTechnologyInput;
	skills?: Prisma.SkillCreateNestedManyWithoutTechnologyInput;
};

export type TechnologyUncheckedCreateInput = {
	id?: string;
	name: string;
	icon?: string | null;
	color?: string | null;
	category?: $Enums.TechnologyCategory | null;
	order?: number;
	projects?: Prisma.ProjectTechnologyUncheckedCreateNestedManyWithoutTechnologyInput;
	skills?: Prisma.SkillUncheckedCreateNestedManyWithoutTechnologyInput;
};

export type TechnologyUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	icon?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	color?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	category?:
		| Prisma.NullableEnumTechnologyCategoryFieldUpdateOperationsInput
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntFieldUpdateOperationsInput | number;
	projects?: Prisma.ProjectTechnologyUpdateManyWithoutTechnologyNestedInput;
	skills?: Prisma.SkillUpdateManyWithoutTechnologyNestedInput;
};

export type TechnologyUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	icon?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	color?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	category?:
		| Prisma.NullableEnumTechnologyCategoryFieldUpdateOperationsInput
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntFieldUpdateOperationsInput | number;
	projects?: Prisma.ProjectTechnologyUncheckedUpdateManyWithoutTechnologyNestedInput;
	skills?: Prisma.SkillUncheckedUpdateManyWithoutTechnologyNestedInput;
};

export type TechnologyCreateManyInput = {
	id?: string;
	name: string;
	icon?: string | null;
	color?: string | null;
	category?: $Enums.TechnologyCategory | null;
	order?: number;
};

export type TechnologyUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	icon?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	color?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	category?:
		| Prisma.NullableEnumTechnologyCategoryFieldUpdateOperationsInput
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type TechnologyUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	icon?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	color?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	category?:
		| Prisma.NullableEnumTechnologyCategoryFieldUpdateOperationsInput
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type TechnologyCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	icon?: Prisma.SortOrder;
	color?: Prisma.SortOrder;
	category?: Prisma.SortOrder;
	order?: Prisma.SortOrder;
};

export type TechnologyAvgOrderByAggregateInput = {
	order?: Prisma.SortOrder;
};

export type TechnologyMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	icon?: Prisma.SortOrder;
	color?: Prisma.SortOrder;
	category?: Prisma.SortOrder;
	order?: Prisma.SortOrder;
};

export type TechnologyMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	icon?: Prisma.SortOrder;
	color?: Prisma.SortOrder;
	category?: Prisma.SortOrder;
	order?: Prisma.SortOrder;
};

export type TechnologySumOrderByAggregateInput = {
	order?: Prisma.SortOrder;
};

export type TechnologyScalarRelationFilter = {
	is?: Prisma.TechnologyWhereInput;
	isNot?: Prisma.TechnologyWhereInput;
};

export type TechnologyNullableScalarRelationFilter = {
	is?: Prisma.TechnologyWhereInput | null;
	isNot?: Prisma.TechnologyWhereInput | null;
};

export type NullableEnumTechnologyCategoryFieldUpdateOperationsInput = {
	set?: $Enums.TechnologyCategory | null;
};

export type TechnologyCreateNestedOneWithoutProjectsInput = {
	create?: Prisma.XOR<
		Prisma.TechnologyCreateWithoutProjectsInput,
		Prisma.TechnologyUncheckedCreateWithoutProjectsInput
	>;
	connectOrCreate?: Prisma.TechnologyCreateOrConnectWithoutProjectsInput;
	connect?: Prisma.TechnologyWhereUniqueInput;
};

export type TechnologyUpdateOneRequiredWithoutProjectsNestedInput = {
	create?: Prisma.XOR<
		Prisma.TechnologyCreateWithoutProjectsInput,
		Prisma.TechnologyUncheckedCreateWithoutProjectsInput
	>;
	connectOrCreate?: Prisma.TechnologyCreateOrConnectWithoutProjectsInput;
	upsert?: Prisma.TechnologyUpsertWithoutProjectsInput;
	connect?: Prisma.TechnologyWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.TechnologyUpdateToOneWithWhereWithoutProjectsInput,
			Prisma.TechnologyUpdateWithoutProjectsInput
		>,
		Prisma.TechnologyUncheckedUpdateWithoutProjectsInput
	>;
};

export type TechnologyCreateNestedOneWithoutSkillsInput = {
	create?: Prisma.XOR<
		Prisma.TechnologyCreateWithoutSkillsInput,
		Prisma.TechnologyUncheckedCreateWithoutSkillsInput
	>;
	connectOrCreate?: Prisma.TechnologyCreateOrConnectWithoutSkillsInput;
	connect?: Prisma.TechnologyWhereUniqueInput;
};

export type TechnologyUpdateOneWithoutSkillsNestedInput = {
	create?: Prisma.XOR<
		Prisma.TechnologyCreateWithoutSkillsInput,
		Prisma.TechnologyUncheckedCreateWithoutSkillsInput
	>;
	connectOrCreate?: Prisma.TechnologyCreateOrConnectWithoutSkillsInput;
	upsert?: Prisma.TechnologyUpsertWithoutSkillsInput;
	disconnect?: Prisma.TechnologyWhereInput | boolean;
	delete?: Prisma.TechnologyWhereInput | boolean;
	connect?: Prisma.TechnologyWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.TechnologyUpdateToOneWithWhereWithoutSkillsInput,
			Prisma.TechnologyUpdateWithoutSkillsInput
		>,
		Prisma.TechnologyUncheckedUpdateWithoutSkillsInput
	>;
};

export type TechnologyCreateWithoutProjectsInput = {
	id?: string;
	name: string;
	icon?: string | null;
	color?: string | null;
	category?: $Enums.TechnologyCategory | null;
	order?: number;
	skills?: Prisma.SkillCreateNestedManyWithoutTechnologyInput;
};

export type TechnologyUncheckedCreateWithoutProjectsInput = {
	id?: string;
	name: string;
	icon?: string | null;
	color?: string | null;
	category?: $Enums.TechnologyCategory | null;
	order?: number;
	skills?: Prisma.SkillUncheckedCreateNestedManyWithoutTechnologyInput;
};

export type TechnologyCreateOrConnectWithoutProjectsInput = {
	where: Prisma.TechnologyWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TechnologyCreateWithoutProjectsInput,
		Prisma.TechnologyUncheckedCreateWithoutProjectsInput
	>;
};

export type TechnologyUpsertWithoutProjectsInput = {
	update: Prisma.XOR<
		Prisma.TechnologyUpdateWithoutProjectsInput,
		Prisma.TechnologyUncheckedUpdateWithoutProjectsInput
	>;
	create: Prisma.XOR<
		Prisma.TechnologyCreateWithoutProjectsInput,
		Prisma.TechnologyUncheckedCreateWithoutProjectsInput
	>;
	where?: Prisma.TechnologyWhereInput;
};

export type TechnologyUpdateToOneWithWhereWithoutProjectsInput = {
	where?: Prisma.TechnologyWhereInput;
	data: Prisma.XOR<
		Prisma.TechnologyUpdateWithoutProjectsInput,
		Prisma.TechnologyUncheckedUpdateWithoutProjectsInput
	>;
};

export type TechnologyUpdateWithoutProjectsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	icon?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	color?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	category?:
		| Prisma.NullableEnumTechnologyCategoryFieldUpdateOperationsInput
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntFieldUpdateOperationsInput | number;
	skills?: Prisma.SkillUpdateManyWithoutTechnologyNestedInput;
};

export type TechnologyUncheckedUpdateWithoutProjectsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	icon?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	color?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	category?:
		| Prisma.NullableEnumTechnologyCategoryFieldUpdateOperationsInput
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntFieldUpdateOperationsInput | number;
	skills?: Prisma.SkillUncheckedUpdateManyWithoutTechnologyNestedInput;
};

export type TechnologyCreateWithoutSkillsInput = {
	id?: string;
	name: string;
	icon?: string | null;
	color?: string | null;
	category?: $Enums.TechnologyCategory | null;
	order?: number;
	projects?: Prisma.ProjectTechnologyCreateNestedManyWithoutTechnologyInput;
};

export type TechnologyUncheckedCreateWithoutSkillsInput = {
	id?: string;
	name: string;
	icon?: string | null;
	color?: string | null;
	category?: $Enums.TechnologyCategory | null;
	order?: number;
	projects?: Prisma.ProjectTechnologyUncheckedCreateNestedManyWithoutTechnologyInput;
};

export type TechnologyCreateOrConnectWithoutSkillsInput = {
	where: Prisma.TechnologyWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TechnologyCreateWithoutSkillsInput,
		Prisma.TechnologyUncheckedCreateWithoutSkillsInput
	>;
};

export type TechnologyUpsertWithoutSkillsInput = {
	update: Prisma.XOR<
		Prisma.TechnologyUpdateWithoutSkillsInput,
		Prisma.TechnologyUncheckedUpdateWithoutSkillsInput
	>;
	create: Prisma.XOR<
		Prisma.TechnologyCreateWithoutSkillsInput,
		Prisma.TechnologyUncheckedCreateWithoutSkillsInput
	>;
	where?: Prisma.TechnologyWhereInput;
};

export type TechnologyUpdateToOneWithWhereWithoutSkillsInput = {
	where?: Prisma.TechnologyWhereInput;
	data: Prisma.XOR<
		Prisma.TechnologyUpdateWithoutSkillsInput,
		Prisma.TechnologyUncheckedUpdateWithoutSkillsInput
	>;
};

export type TechnologyUpdateWithoutSkillsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	icon?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	color?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	category?:
		| Prisma.NullableEnumTechnologyCategoryFieldUpdateOperationsInput
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntFieldUpdateOperationsInput | number;
	projects?: Prisma.ProjectTechnologyUpdateManyWithoutTechnologyNestedInput;
};

export type TechnologyUncheckedUpdateWithoutSkillsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	icon?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	color?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	category?:
		| Prisma.NullableEnumTechnologyCategoryFieldUpdateOperationsInput
		| $Enums.TechnologyCategory
		| null;
	order?: Prisma.IntFieldUpdateOperationsInput | number;
	projects?: Prisma.ProjectTechnologyUncheckedUpdateManyWithoutTechnologyNestedInput;
};

/**
 * Count Type TechnologyCountOutputType
 */

export type TechnologyCountOutputType = {
	projects: number;
	skills: number;
};

export type TechnologyCountOutputTypeSelect<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	projects?: boolean | TechnologyCountOutputTypeCountProjectsArgs;
	skills?: boolean | TechnologyCountOutputTypeCountSkillsArgs;
};

/**
 * TechnologyCountOutputType without action
 */
export type TechnologyCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the TechnologyCountOutputType
	 */
	select?: Prisma.TechnologyCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * TechnologyCountOutputType without action
 */
export type TechnologyCountOutputTypeCountProjectsArgs<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.ProjectTechnologyWhereInput;
};

/**
 * TechnologyCountOutputType without action
 */
export type TechnologyCountOutputTypeCountSkillsArgs<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.SkillWhereInput;
};

export type TechnologySelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		name?: boolean;
		icon?: boolean;
		color?: boolean;
		category?: boolean;
		order?: boolean;
		projects?: boolean | Prisma.Technology$projectsArgs<ExtArgs>;
		skills?: boolean | Prisma.Technology$skillsArgs<ExtArgs>;
		_count?: boolean | Prisma.TechnologyCountOutputTypeDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["technology"]
>;

export type TechnologySelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		name?: boolean;
		icon?: boolean;
		color?: boolean;
		category?: boolean;
		order?: boolean;
	},
	ExtArgs["result"]["technology"]
>;

export type TechnologySelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		name?: boolean;
		icon?: boolean;
		color?: boolean;
		category?: boolean;
		order?: boolean;
	},
	ExtArgs["result"]["technology"]
>;

export type TechnologySelectScalar = {
	id?: boolean;
	name?: boolean;
	icon?: boolean;
	color?: boolean;
	category?: boolean;
	order?: boolean;
};

export type TechnologyOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	"id" | "name" | "icon" | "color" | "category" | "order",
	ExtArgs["result"]["technology"]
>;
export type TechnologyInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	projects?: boolean | Prisma.Technology$projectsArgs<ExtArgs>;
	skills?: boolean | Prisma.Technology$skillsArgs<ExtArgs>;
	_count?: boolean | Prisma.TechnologyCountOutputTypeDefaultArgs<ExtArgs>;
};
export type TechnologyIncludeCreateManyAndReturn<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {};
export type TechnologyIncludeUpdateManyAndReturn<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {};

export type $TechnologyPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "Technology";
	objects: {
		projects: Prisma.$ProjectTechnologyPayload<ExtArgs>[];
		skills: Prisma.$SkillPayload<ExtArgs>[];
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			name: string;
			icon: string | null;
			color: string | null;
			category: $Enums.TechnologyCategory | null;
			order: number;
		},
		ExtArgs["result"]["technology"]
	>;
	composites: {};
};

export type TechnologyGetPayload<
	S extends boolean | null | undefined | TechnologyDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$TechnologyPayload, S>;

export type TechnologyCountArgs<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<TechnologyFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
	select?: TechnologyCountAggregateInputType | true;
};

export interface TechnologyDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["Technology"];
		meta: { name: "Technology" };
	};
	/**
	 * Find zero or one Technology that matches the filter.
	 * @param {TechnologyFindUniqueArgs} args - Arguments to find a Technology
	 * @example
	 * // Get one Technology
	 * const technology = await prisma.technology.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends TechnologyFindUniqueArgs>(
		args: Prisma.SelectSubset<T, TechnologyFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__TechnologyClient<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one Technology that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {TechnologyFindUniqueOrThrowArgs} args - Arguments to find a Technology
	 * @example
	 * // Get one Technology
	 * const technology = await prisma.technology.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends TechnologyFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, TechnologyFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__TechnologyClient<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Technology that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TechnologyFindFirstArgs} args - Arguments to find a Technology
	 * @example
	 * // Get one Technology
	 * const technology = await prisma.technology.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends TechnologyFindFirstArgs>(
		args?: Prisma.SelectSubset<T, TechnologyFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__TechnologyClient<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Technology that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TechnologyFindFirstOrThrowArgs} args - Arguments to find a Technology
	 * @example
	 * // Get one Technology
	 * const technology = await prisma.technology.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends TechnologyFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, TechnologyFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__TechnologyClient<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more Technologies that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TechnologyFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Technologies
	 * const technologies = await prisma.technology.findMany()
	 *
	 * // Get first 10 Technologies
	 * const technologies = await prisma.technology.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const technologyWithIdOnly = await prisma.technology.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends TechnologyFindManyArgs>(
		args?: Prisma.SelectSubset<T, TechnologyFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a Technology.
	 * @param {TechnologyCreateArgs} args - Arguments to create a Technology.
	 * @example
	 * // Create one Technology
	 * const Technology = await prisma.technology.create({
	 *   data: {
	 *     // ... data to create a Technology
	 *   }
	 * })
	 *
	 */
	create<T extends TechnologyCreateArgs>(
		args: Prisma.SelectSubset<T, TechnologyCreateArgs<ExtArgs>>,
	): Prisma.Prisma__TechnologyClient<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many Technologies.
	 * @param {TechnologyCreateManyArgs} args - Arguments to create many Technologies.
	 * @example
	 * // Create many Technologies
	 * const technology = await prisma.technology.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends TechnologyCreateManyArgs>(
		args?: Prisma.SelectSubset<T, TechnologyCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many Technologies and returns the data saved in the database.
	 * @param {TechnologyCreateManyAndReturnArgs} args - Arguments to create many Technologies.
	 * @example
	 * // Create many Technologies
	 * const technology = await prisma.technology.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many Technologies and only return the `id`
	 * const technologyWithIdOnly = await prisma.technology.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends TechnologyCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, TechnologyCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a Technology.
	 * @param {TechnologyDeleteArgs} args - Arguments to delete one Technology.
	 * @example
	 * // Delete one Technology
	 * const Technology = await prisma.technology.delete({
	 *   where: {
	 *     // ... filter to delete one Technology
	 *   }
	 * })
	 *
	 */
	delete<T extends TechnologyDeleteArgs>(
		args: Prisma.SelectSubset<T, TechnologyDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__TechnologyClient<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one Technology.
	 * @param {TechnologyUpdateArgs} args - Arguments to update one Technology.
	 * @example
	 * // Update one Technology
	 * const technology = await prisma.technology.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends TechnologyUpdateArgs>(
		args: Prisma.SelectSubset<T, TechnologyUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__TechnologyClient<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more Technologies.
	 * @param {TechnologyDeleteManyArgs} args - Arguments to filter Technologies to delete.
	 * @example
	 * // Delete a few Technologies
	 * const { count } = await prisma.technology.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends TechnologyDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, TechnologyDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Technologies.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TechnologyUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Technologies
	 * const technology = await prisma.technology.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends TechnologyUpdateManyArgs>(
		args: Prisma.SelectSubset<T, TechnologyUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Technologies and returns the data updated in the database.
	 * @param {TechnologyUpdateManyAndReturnArgs} args - Arguments to update many Technologies.
	 * @example
	 * // Update many Technologies
	 * const technology = await prisma.technology.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more Technologies and only return the `id`
	 * const technologyWithIdOnly = await prisma.technology.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends TechnologyUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, TechnologyUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one Technology.
	 * @param {TechnologyUpsertArgs} args - Arguments to update or create a Technology.
	 * @example
	 * // Update or create a Technology
	 * const technology = await prisma.technology.upsert({
	 *   create: {
	 *     // ... data to create a Technology
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Technology we want to update
	 *   }
	 * })
	 */
	upsert<T extends TechnologyUpsertArgs>(
		args: Prisma.SelectSubset<T, TechnologyUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__TechnologyClient<
		runtime.Types.Result.GetResult<
			Prisma.$TechnologyPayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of Technologies.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TechnologyCountArgs} args - Arguments to filter Technologies to count.
	 * @example
	 * // Count the number of Technologies
	 * const count = await prisma.technology.count({
	 *   where: {
	 *     // ... the filter for the Technologies we want to count
	 *   }
	 * })
	 **/
	count<T extends TechnologyCountArgs>(
		args?: Prisma.Subset<T, TechnologyCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<T["select"], TechnologyCountAggregateOutputType>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a Technology.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TechnologyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends TechnologyAggregateArgs>(
		args: Prisma.Subset<T, TechnologyAggregateArgs>,
	): Prisma.PrismaPromise<GetTechnologyAggregateType<T>>;

	/**
	 * Group by Technology.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TechnologyGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends TechnologyGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: TechnologyGroupByArgs["orderBy"] }
			: { orderBy?: TechnologyGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, TechnologyGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetTechnologyGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the Technology model
	 */
	readonly fields: TechnologyFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Technology.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__TechnologyClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	projects<T extends Prisma.Technology$projectsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Technology$projectsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$ProjectTechnologyPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	skills<T extends Prisma.Technology$skillsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Technology$skillsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$SkillPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Technology model
 */
export interface TechnologyFieldRefs {
	readonly id: Prisma.FieldRef<"Technology", "String">;
	readonly name: Prisma.FieldRef<"Technology", "String">;
	readonly icon: Prisma.FieldRef<"Technology", "String">;
	readonly color: Prisma.FieldRef<"Technology", "String">;
	readonly category: Prisma.FieldRef<"Technology", "TechnologyCategory">;
	readonly order: Prisma.FieldRef<"Technology", "Int">;
}

// Custom InputTypes
/**
 * Technology findUnique
 */
export type TechnologyFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
	/**
	 * Filter, which Technology to fetch.
	 */
	where: Prisma.TechnologyWhereUniqueInput;
};

/**
 * Technology findUniqueOrThrow
 */
export type TechnologyFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
	/**
	 * Filter, which Technology to fetch.
	 */
	where: Prisma.TechnologyWhereUniqueInput;
};

/**
 * Technology findFirst
 */
export type TechnologyFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
	/**
	 * Filter, which Technology to fetch.
	 */
	where?: Prisma.TechnologyWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Technologies to fetch.
	 */
	orderBy?:
		| Prisma.TechnologyOrderByWithRelationInput
		| Prisma.TechnologyOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Technologies.
	 */
	cursor?: Prisma.TechnologyWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Technologies from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Technologies.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Technologies.
	 */
	distinct?:
		| Prisma.TechnologyScalarFieldEnum
		| Prisma.TechnologyScalarFieldEnum[];
};

/**
 * Technology findFirstOrThrow
 */
export type TechnologyFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
	/**
	 * Filter, which Technology to fetch.
	 */
	where?: Prisma.TechnologyWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Technologies to fetch.
	 */
	orderBy?:
		| Prisma.TechnologyOrderByWithRelationInput
		| Prisma.TechnologyOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Technologies.
	 */
	cursor?: Prisma.TechnologyWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Technologies from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Technologies.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Technologies.
	 */
	distinct?:
		| Prisma.TechnologyScalarFieldEnum
		| Prisma.TechnologyScalarFieldEnum[];
};

/**
 * Technology findMany
 */
export type TechnologyFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
	/**
	 * Filter, which Technologies to fetch.
	 */
	where?: Prisma.TechnologyWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Technologies to fetch.
	 */
	orderBy?:
		| Prisma.TechnologyOrderByWithRelationInput
		| Prisma.TechnologyOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Technologies.
	 */
	cursor?: Prisma.TechnologyWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Technologies from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Technologies.
	 */
	skip?: number;
	distinct?:
		| Prisma.TechnologyScalarFieldEnum
		| Prisma.TechnologyScalarFieldEnum[];
};

/**
 * Technology create
 */
export type TechnologyCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
	/**
	 * The data needed to create a Technology.
	 */
	data: Prisma.XOR<
		Prisma.TechnologyCreateInput,
		Prisma.TechnologyUncheckedCreateInput
	>;
};

/**
 * Technology createMany
 */
export type TechnologyCreateManyArgs<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many Technologies.
	 */
	data: Prisma.TechnologyCreateManyInput | Prisma.TechnologyCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * Technology createManyAndReturn
 */
export type TechnologyCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * The data used to create many Technologies.
	 */
	data: Prisma.TechnologyCreateManyInput | Prisma.TechnologyCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * Technology update
 */
export type TechnologyUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
	/**
	 * The data needed to update a Technology.
	 */
	data: Prisma.XOR<
		Prisma.TechnologyUpdateInput,
		Prisma.TechnologyUncheckedUpdateInput
	>;
	/**
	 * Choose, which Technology to update.
	 */
	where: Prisma.TechnologyWhereUniqueInput;
};

/**
 * Technology updateMany
 */
export type TechnologyUpdateManyArgs<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update Technologies.
	 */
	data: Prisma.XOR<
		Prisma.TechnologyUpdateManyMutationInput,
		Prisma.TechnologyUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Technologies to update
	 */
	where?: Prisma.TechnologyWhereInput;
	/**
	 * Limit how many Technologies to update.
	 */
	limit?: number;
};

/**
 * Technology updateManyAndReturn
 */
export type TechnologyUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * The data used to update Technologies.
	 */
	data: Prisma.XOR<
		Prisma.TechnologyUpdateManyMutationInput,
		Prisma.TechnologyUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Technologies to update
	 */
	where?: Prisma.TechnologyWhereInput;
	/**
	 * Limit how many Technologies to update.
	 */
	limit?: number;
};

/**
 * Technology upsert
 */
export type TechnologyUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
	/**
	 * The filter to search for the Technology to update in case it exists.
	 */
	where: Prisma.TechnologyWhereUniqueInput;
	/**
	 * In case the Technology found by the `where` argument doesn't exist, create a new Technology with this data.
	 */
	create: Prisma.XOR<
		Prisma.TechnologyCreateInput,
		Prisma.TechnologyUncheckedCreateInput
	>;
	/**
	 * In case the Technology was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.TechnologyUpdateInput,
		Prisma.TechnologyUncheckedUpdateInput
	>;
};

/**
 * Technology delete
 */
export type TechnologyDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
	/**
	 * Filter which Technology to delete.
	 */
	where: Prisma.TechnologyWhereUniqueInput;
};

/**
 * Technology deleteMany
 */
export type TechnologyDeleteManyArgs<
	_ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Technologies to delete
	 */
	where?: Prisma.TechnologyWhereInput;
	/**
	 * Limit how many Technologies to delete.
	 */
	limit?: number;
};

/**
 * Technology.projects
 */
export type Technology$projectsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ProjectTechnology
	 */
	select?: Prisma.ProjectTechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the ProjectTechnology
	 */
	omit?: Prisma.ProjectTechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ProjectTechnologyInclude<ExtArgs> | null;
	where?: Prisma.ProjectTechnologyWhereInput;
	orderBy?:
		| Prisma.ProjectTechnologyOrderByWithRelationInput
		| Prisma.ProjectTechnologyOrderByWithRelationInput[];
	cursor?: Prisma.ProjectTechnologyWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.ProjectTechnologyScalarFieldEnum
		| Prisma.ProjectTechnologyScalarFieldEnum[];
};

/**
 * Technology.skills
 */
export type Technology$skillsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Skill
	 */
	select?: Prisma.SkillSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Skill
	 */
	omit?: Prisma.SkillOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.SkillInclude<ExtArgs> | null;
	where?: Prisma.SkillWhereInput;
	orderBy?:
		| Prisma.SkillOrderByWithRelationInput
		| Prisma.SkillOrderByWithRelationInput[];
	cursor?: Prisma.SkillWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.SkillScalarFieldEnum | Prisma.SkillScalarFieldEnum[];
};

/**
 * Technology without action
 */
export type TechnologyDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Technology
	 */
	select?: Prisma.TechnologySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Technology
	 */
	omit?: Prisma.TechnologyOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TechnologyInclude<ExtArgs> | null;
};
